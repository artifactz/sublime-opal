# [PackageDev] target_format: plist, ext: tmLanguage
# http://www.geocities.jp/kosako3/oniguruma/doc/RE.txt
# http://manual.macromates.com/en/language_grammars
---
name: Opal
scopeName: source.opal
fileTypes: [impl, sign]
uuid: 3da0f3f0-8b32-41c9-857c-ce9be39b99d4

patterns:

# comments
- name: comment.line.double-dash.opal
  match: (\-\-).*$
  captures:
    '1': { name: punctuation.definition.comment.opal }
- name: comment.block.opal
  begin: (/\*)
  end: (\*/)
  captures:
    '1': { name: punctuation.definition.comment.block.opal }

# meta keywords
- name: keyword.meta.opal
  match: ^\s*(SIGNATURE|IMPLEMENTATION)\b
- name: keyword.control.import.opal
  match: (^\s*IMPORT|\b(ONLY|COMPLETELY))\b

# FUN declaration
- name: meta.function.opal
  begin: ^\s*(FUN)\s+([^\s():]+)\s*(\:) # \S = non-whitespace character
  end: ($)|(?=\-\-)|(?=/\*)
  contentName: meta.function.parameters.opal
  beginCaptures:
    '1': { name: storage.type.function.opal }
    '2': { name: entity.name.function.opal }
    '3': { name: punctuation.definition.parameters.begin.opal }
#  endCaptures:
#    '1': { name: punctuation.definition.parameters.end.opal }
  patterns:
  - name: punctuation.seperator.parameters.opal
    match: \*\*|\->
  - name: variable.parameter.opal
    match: \b(nat|char|real|denotation|bool|seq)\b

# infix DEF definition
- name: meta.function.opal
  match: ^\s*(DEF)\s+([^\s():]+)\s+([^\s():]+)\s+([^\s():]+)\s*(==)
  captures:
    '1': { name: storage.type.function.opal }
    '2': { name: variable.parameter.opal }
    '3': { name: entity.name.function.opal }
    '4': { name: variable.parameter.opal }
    '5': { name: punctuation.section.function.begin.opal }

# DEF definition
- name: meta.function.opal
  begin: ^\s*(DEF)\s+([^\s():]+)\s*(?:(\())?
  end: (?:(\)))?\s*(==)
  beginCaptures:
    '1': { name: storage.type.function.opal }
    '2': { name: entity.name.function.opal }
    '3': { name: punctuation.definition.parameters.begin.opal }
  endCaptures:
    '1': { name: punctuation.definition.parameters.end.opal }
    '2': { name: punctuation.section.function.begin.opal }
  patterns:
  - name: punctuation.seperator.parameters.opal
    match: \,
  - name: variable.parameter.opal
    match: \w*

# SORT declaration
- name: meta.type.sort.opal
  begin: ^\s*(SORT)
  end: $
  beginCaptures:
    '1': { name: storage.type.sort.opal }
  patterns:
  - name: entity.name.function.type.sort.opal
    match: \b[^\s():]+\b

# DATA/TYPE definition
- name: meta.type.data.opal
  begin: ^\s*(DATA|TYPE)\s+([^\s():]+)\s*
  end: \s*(==)
  beginCaptures:
    '1': { name: storage.type.data.opal }
    '2': { name: entity.name.function.type.data.opal }
  endCaptures:
    '1': { name: punctuation.section.type.begin.opal }

# sequences
- name: meta.structure.list.opal
  begin: (?=\w+(?:\s*::\s*\w+)*\s*::\s+<>)
  end: (<>)
  endCaptures:
    '1': { name: punctuation.definition.list.end.opal }
  patterns:
  - match: (::)
    name: punctuation.separator.list.opal
  - include: '#evaluable'

- name: meta.structure.tuple.opal
  begin: (\()
  end: (\))
  beginCaptures:
    '1': { name: punctuation.definition.tuple.begin.opal }
  endCaptures:
    '1': { name: punctuation.definition.tuple.end.opal }
  patterns:
  - match: (,)
    name: punctuation.separator.tuple.opal
  - include: '#evaluable'

- include: '#evaluable'

# builtin types
- name: support.type.opal
  match: \b(Nat|Char|Real|Denotation|Bool|Seq)\b

repository:
  evaluable:
    patterns:
    # anonymous lambda function
      - name: meta.function.opal
        begin: (\\\\)
        end: (\.)
        beginCaptures:
          '1': { name: storage.type.function.opal }
        endCaptures:
          '1': { name: punctuation.section.function.begin.opal }
        patterns:
        - name: punctuation.seperator.parameters.opal
          match: \s*\,\s*
        - name: variable.parameter.opal
          match: \w*

    # strings
      - name: string.quoted.double.opal
        begin: (")
        end: (")(?!\!)|(\n)
        beginCaptures:
          '1': { name: punctuation.definition.string.begin.opal }
        endCaptures:
          '1': { name: punctuation.definition.string.end.opal }
          '3': { name: invalid.illegal.unclosed-string.opal }

    # character
      - name: constant.character.opal
        match: \".\"!
    # numbers
      - name: constant.numeric.integer.opal
        match: (\b(0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|64|128|256|512|1024|100|1000|10000|100000|1000000)\b)|\"\d+\"!
      - name: invalid.illegal.empty-number.opal
        match: \"\.?\"!
      - name: constant.numeric.real.opal
        #match: \"(\d*\.\d+|\d+\.\d*)\"!
        match: \"[+-]?\d*(\.\d*)?(e[+-]?\d+)?\"!
        # https://projects.uebb.tu-berlin.de/opal/dosfop/2.4a/bibopalicaman/Real.html
      - name: constant.numeric.hexadecimal.opal
        match: \"0x\h+\"!
      - name: invalid.illegal.unexpected-number.opal
        match: \".*\"!

    # builtin functions
      - name: support.function.builtin.opal
        match: \b(map|filter|zip|sqrt)\b
      - name: support.function.builtin.opal
        match: <>\?|<>(?!\?)

    # evaluable keywords
      - name: keyword.control.opal
        match: \b(IF|THEN|ELSE|OTHERWISE|FI)\b
      - name: keyword.other.opal
        match: \b(LET|IN|WHERE)\b
      - name: keyword.operator.comparison.opal
        match: (<=|>=|<|>|\|=|(?<!=)=(?!=))
      - name: keyword.operator.arithmetic.opal
        match: (\+|\-|\*|/|\bdiv\b|\^|\bpow\b|%|\bmod\b)
      - name: keyword.operator.logical.opal
        match: \b(and|or|not)\b
...
